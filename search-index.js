var searchIndex = {};
searchIndex["raw_vec"] = {"doc":"","items":[[3,"RawVec","raw_vec","A low-level utility for more ergonomically allocating, reallocating, and deallocating a\na buffer of memory on the heap without having to worry about all the corner cases\ninvolved. This type is excellent for building your own data structures like Vec and VecDeque.\nIn particular:",null,null],[11,"new","","Creates the biggest possible RawVec without allocating. If T has positive\nsize, then this makes a RawVec with capacity 0. If T has 0 size, then it\nit makes a RawVec with capacity `usize::MAX`. Useful for implementing\ndelayed allocation.",0,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Creates a RawVec with exactly the capacity and alignment requirements\nfor a `[T; cap]`. This is equivalent to calling RawVec::new when `cap` is 0\nor T is zero-sized. Note that if `T` is zero-sized this means you will *not*\nget a RawVec with the requested capacity!",0,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"from_raw_parts","","Reconstitutes a RawVec from a pointer and capacity.",0,null],[11,"from_box","","Converts a `Box&lt;[T]&gt;` into a `RawVec&lt;T&gt;`.",0,{"inputs":[{"name":"box"}],"output":{"name":"self"}}],[11,"ptr","","Gets a raw pointer to the start of the allocation. Note that this is\nheap::EMPTY if `cap = 0` or T is zero-sized. In the former case, you must\nbe careful.",0,null],[11,"cap","","Gets the capacity of the allocation.",0,null],[11,"double","","Doubles the size of the type&#39;s backing allocation. This is common enough\nto want to do that it&#39;s easiest to just have a dedicated method. Slightly\nmore efficient logic can be provided for this than the general case.",0,null],[11,"double_in_place","","Attempts to double the size of the type&#39;s backing allocation in place. This is common\nenough to want to do that it&#39;s easiest to just have a dedicated method. Slightly\nmore efficient logic can be provided for this than the general case.",0,null],[11,"reserve_exact","","Ensures that the buffer contains at least enough space to hold\n`used_cap + needed_extra_cap` elements. If it doesn&#39;t already,\nwill reallocate the minimum possible amount of memory necessary.\nGenerally this will be exactly the amount of memory necessary,\nbut in principle the allocator is free to give back more than\nwe asked for.",0,null],[11,"reserve","","Ensures that the buffer contains at least enough space to hold\n`used_cap + needed_extra_cap` elements. If it doesn&#39;t already have\nenough capacity, will reallocate enough space plus comfortable slack\nspace to get amortized `O(1)` behavior. Will limit this behavior\nif it would needlessly cause itself to panic.",0,null],[11,"reserve_in_place","","Attempts to ensure that the buffer contains at least enough space to hold\n`used_cap + needed_extra_cap` elements. If it doesn&#39;t already have\nenough capacity, will reallocate in place enough space plus comfortable slack\nspace to get amortized `O(1)` behaviour. Will limit this behaviour\nif it would needlessly cause itself to panic.",0,null],[11,"shrink_to_fit","","Shrinks the allocation down to the specified amount. If the given amount\nis 0, actually completely deallocates.",0,null],[11,"into_box","","Converts the entire buffer into `Box&lt;[T]&gt;`.",0,null],[11,"unsafe_no_drop_flag_needs_drop","","This is a stupid name in the hopes that someone will find this in the\nnot too distant future and remove it with the rest of\n#[unsafe_no_drop_flag]",0,null],[11,"drop","","Frees the memory owned by the RawVec *without* trying to Drop its contents.",0,null]],"paths":[[3,"RawVec"]]};
initSearch(searchIndex);
